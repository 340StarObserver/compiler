## 如何把NFA确定化为DFA ##


我们使用子集构造法来进行NFA的确定化，首先来关注几个使用频繁的操作  


### 一.　根据NFA中结点编号，快速定位到对应结点 ###

        n = NFA的终结结点的编号  
        // 终结结点的编号是多少，那么这个NFA就有多少个结点  
        
        创建一个长度为n+1的结点指针数组，记为 nodes  
        // 用以临时保存这n个结点的地址，以便直接通过结点编号来定位到对应结点  
        // 实际使用的下标范围是 [1,n]  
        
        对NFA做广度优先搜索，把每个结点的地址填入上面所说的指针数组中  
        // 例如，某个结点的编号是i，那么 nodes[i]=该结点地址  
        // 因为NFA是有向有环图，所以在做BFS的时候注意验重  
        
        // 上述的预处理做完后，之后我就可以在O(1)时间内快速定位结点了  



### 二.　状态集的ε闭包 ###

        创建一个空集合，记为 s  

        创建一个空队列，并把这个状态集中的所有元素入队  
        
        接下来的操作仍然是BFS  
        // 在处理某个结点的时候 :  
        // 　　if 该结点 ∉ s :  
        // 　　　　把该结点加入到 s  
        // 　　　　把该结点的所有 直接的ε后继，都入队  
        
        // 做完BFS之后，s即为该状态集的ε闭包  



### 三.　状态集经过某个终结符vt，得到一个新的状态集 ###

        创建一个空集合，记为 s  
        
        对于该状态集中的每个元素 :  
            把该元素的所有的直接vt后继，加入到s中  
        
        // 该操作结束后，往往紧接着求ε闭包  
        // 例如， I1 = ε闭包（I0的vt后继）  



### 四.　判断两个状态集是否等同 ###

        记两个状态集为 S1 S2  
        
        if S1.size() != S2.size()  
            return false  
            // 元素个数不相等，则两个状态集肯定不等  
        
        遍历S1中的所有元素，若每个元素在S2中都能找到，则两个状态集相等  



### 五.　判断一个状态集是否是DFA的一个终结态 ###

        记原来NFA的终结结点的编号为 end_id  
        
        该状态集包含 end_id 这个元素，则该状态集是DFA的一个终结态；反之不是  



有了上述的几个操作后，我们可以制定出子集构造法的算法流程  


### 六.　子集构造法的算法流程 ###

        创建一个状态转化表，记为 table  
        // 列数 = 终结符的总个数  
        // 行数 不固定  
        
        创建一个容器，记为 I-list  
        // 用来存储 I0,I1,...  
        // 形如 I-list = [ I0={1,3,5}, I1={2,4,6} ]  
        
        I0 = ε闭包（NFA的起始结点）  
        把 I0 添加到 I-list  
        
        创建一个空队列，记为 Q  
        把 I0 入队  
        
        i = 1  
        // Ii的计数器  
        
        while( Q 非空 )  
        {  
            从队首取出一个元素，记为 I-cur  
            
            对于每个终结符vt :  
            {  
                计算 ε闭包（I-cur的vt后继），记为 I-tmp  
                
                if( I-tmp 是 ∅ )  
                    table[I-cur][vt] = ∅  
                
                else if( I-tmp 在 I-list中，且下标为j )  
                    table[I-cur][vt] = Ij  
                
                else  
                {  
                    这个I-tmp是一个新的I，就是Ii  
                    table[I-cur][vt] = Ii  
                    把 Ii 添加到 I-list  
                    把 Ii 入队  
                    i++  
                }  
            }  
        }  
        
        // 至此，我们把状态转化表table计算完毕  
        
        // 但是，还差一步，是计算出有哪些I是终结状态，哪些不是  
        // 创建一个数组 mark[] :  
        // 　　mark[i] 代表了Ii是否是一个终结结点  
        // 　　{  
        // 　　   mark[i] == true  , Ii包含原来NFA的终结结点  
        // 　　   mark[i] == false , Ii不包含原来NFA的终结结点  
        // 　　}  
        
        // 至此，table表 & mark表 共同构成一个DFA的必备信息  
