## 如何用ODFA来识别一段文本 ##


### 一.　扫描程序的伪代码 ###

        /*  
        参数解释 :  
            待扫描文本 : text  
            结果输出流 : resOut，一个类似流对象的东西，用来把词法分析的结果输出到屏幕或者文件等  
            报错输出流 : errorOut，一个类似流对象的东西，用来把报错信息输出到屏幕或者文件等  
        */  
        function( text, resOut, errorOut )  
        {  
        
            T[] = ODFA.终结结点-正则类型-对应表  
                // 其中 :  
                //     T[i] == 0, 表示状态i不是终结状态  
                //     T[i] != 0, 表示状态i是终结状态，且对应的正则的类型是T[i]  
            
            
            curS = ODFA.入口状态  
                // 一开始的时候，自动机的状态是ODFA的入口  
            
            
            p1 = p2 = 0  
                // p1 用来标记一个子串的开头位置，p2 用来标记一个子串的结束位置  
                // 即 text[p1 : p2] 是识别到的一个子串  
            
            
            cnt = 0  
                // 内码计数器  
            
            
            while( 1 )  
            {  
                while( p2 < text.length && text[p2] == 空白符 )  
                    p2++  
                    // 连续跳过空白符（空格 or Tab or 换行符）  
                
                if( p2 >= text.length )  
                    return  
                
                p1 = p2  
                    // 找到了一个子串的开头位置  
                
                /* 下面走自动机 */  
                while( p2 < text.length )  
                {  
                    curS = 找后继状态(curS, text[p2])  
                        // 更新当前状态  
                    
                    if( curS == -1 )  
                    {   /* 走不通 */  
                    
                        把 text[p1 : p2] 这个错误的串，写到报错输出流中  
                        p2++  
                        break  
                        // 跳过此错误，继续扫描（为了一次性查出所有错误）  
                    }  
                
                    else if( T[curS] != 0 )  
                    {   /* 走到了一个终结结点上 */  
                    
                        子串是为           text[p1 : p2]  
                        子串对应的正则类型是 T[curS]  
                        子串的内码是        ++cnt  
                        
                        把（内码，子串，类型）写到结果输出流  
                        p2++  
                        break  
                    }  
                    
                    else  
                        p2++  
                }   
                
                /* 下面检查文本末尾的那一个子串，是否走到了终结状态 */  
                if( p2 == text.length && curS != -1 && T[curS] == 0 )  
                {   /* text[p1 : p2] 还没正常结束 */  
                    把 text[p1 : p2] 这个错误的串，写到报错输出流中  
                }  
            }  
            
        }  
