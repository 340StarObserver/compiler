## 如何把中缀正则转化为后缀正则 ##



### 一. 关于正则表达式中的运算符 ###

        1-1. 有一个函数，判断一个字符是否是目前支持的正则表达式中的运算符  

        1-2. 有一个函数，求出运算符对应的优先级（包括栈外优先级，栈内优先级）  
        
            运算符        栈外优先级        栈内优先级  
            (               7               1  
            )               1               7  
            *               6               6  
            |               2               3  
            .               4               3  
        
        1-3. 有一个函数，求出运算对应的几元性质（是一元运算符还是二元运算符）  



### 二. 准备2个栈 ###

        2-1. 运算符栈A （用来在进行中缀转后缀工作时，存放正则表达式中的运算符）  
        
        2-2. 表达式栈B （用来在进行中缀转后缀工作时，存放正则表达式中的终结符和临时后缀）  



### 三. 封装一个操作（会在下面的算法流程中反复用到），记为 action ###

        从栈A中弹出一个运算符，记作 op  
        
        if op 是一元运算符 :  
            从栈B中弹出一个表达式，记作 exp  
            把 exp op 这个整体压入栈B  
            // 例如，op是*，exp是ab|，则把 ab|* 这个整体作为一个临时后缀，压入栈B  
            
        if op 是二元运算符 :  
            从栈B中依次弹出两个表达式，记作 exp1 exp2  
            把 exp2 exp1 op 这个整体（注意exp1和exp2的顺序）压入栈B  
            // 例如，op是.，从栈A先弹出exp1=a，再弹出exp2=b，则把 ba. 这个整体压入栈B  



### 四. 算法流程 ###

        n = strlen(中缀正则表达式)  
        i = 0  
        // i 指向中缀正则的第零个位置  
        
        while( i < n )  
        {  
            ch = 中缀正则[i]  
            
            if( ch 是运算符 && ch 不是右括号 )  
            {  
                if( 栈A非空 && ch的栈外优先级 < 栈A的栈顶运算符的栈内优先级 )  
                    执行操作 action  
                else  
                {  
                    把 ch 压入栈A  
                    i++  
                }  
            }  
            
            else if( ch 是右括号 )  
            {  
                do{  
                    执行操作 action  
                }while( op 不是左括号 );  
                
                把栈A顶部的左括号弹出  
                i++  
            }  
            
            else  
            {  
                // 这种情况即 ch是普通的终结符  
                把 ch 压入栈B  
                i++  
            }  
        }  
        
        // 扫描完整个中缀正则后，再整理两个栈  
        while( 栈A非空 && 栈B非空 )  
            执行操作 action  
        
        // 最后，栈B的顶部元素就是最终的后缀正则表达式  
        return B.top  



### 五. 举个梨子 ###

        中缀正则 ： (a.b|c)*.(d|e)*  
        
        i = 0, ch = '('  
            栈A = [ '('  
            栈B = [  
            // [表示栈底  
        
        i = 1, ch = 'a'  
            栈A = [ '('  
            栈B = [ "a"  
        
        i = 2, ch = '.'  
            栈A = [ '(', '.'  
            栈B = [ "a"  
        
        i = 3, ch = 'b'  
            栈A = [ '(', '.'  
            栈B = [ "a", "b"  
        
        i = 4, ch = '|'  
            栈A = [ '('  
            栈B = [ "ab."  
        
        i = 4, ch = '|'  
            栈A = [ '(', '|'  
            栈B = [ "ab."  
        
        i = 5, ch = 'c'  
            栈A = [ '(', '|'  
            栈B = [ "ab.", "c"  
        
        i = 6, ch = ')'  
            栈A = [  
            栈B = [ "ab.c|"  
        
        i = 7, ch = '*'  
            栈A = [ '*'  
            栈B = [ "ab.c|"  
        
        i = 8, ch = '.'  
            栈A = [  
            栈B = [ "ab.c|*"  
        
        i = 8, ch = '.'  
            栈A = [ '.'  
            栈B = [ "ab.c|*"  
        
        i = 9, ch = '('  
            栈A = [ '.', '('  
            栈B = [ "ab.c|*"  
        
        i = 10, ch = 'd'  
            栈A = [ '.', '('  
            栈B = [ "ab.c|*", "d"  
        
        i = 11, ch = '|'  
            栈A = [ '.', '(', '|'  
            栈B = [ "ab.c|*", "d"  
        
        i = 12, ch = 'e'  
            栈A = [ '.', '(', '|'  
            栈B = [ "ab.c|*", "d", "e"  
        
        i = 13, ch = ')'  
            栈A = [ '.'  
            栈B = [ "ab.c|*", "de|"  
        
        i = 14, ch = '*'  
            栈A = [ '.', '*'  
            栈B = [ "ab.c|*", "de|"  
        
        // 至此，扫描完毕，接下来不断用action操作来整理这两个栈即可  
        
        第一次整理  
            栈A = [ '.'  
            栈B = [ "ab.c|*", "de|*"  
        
        第二次整理  
            栈A = [  
            栈B = [ "ab.c|*de|*."  
        
        // 好了，现在 栈A非空&&栈B非空的条件 不满足了，可以终止了  
        // 最终，后缀正则就是栈B里的 ab.c|*de|*.  
