## 如何用ODFA扫描文本 ##


### 一.　方略 ###

        1. 跳过连续的空白符，走到第一个不是空白符的终结符，记为 p  
        
        2. 从这个终结符的地方开始，走自动机，直至走到第一个终结结点  
            // 若在此过程中，自动机没有相应的后继状态，则报错  
        
        3. 从这个终结结点的地方开始，继续走自动机，直至没有相应的后继结点or走到了一个非终结结点，记为q  
            // 目的是为了看完一个完整的单词  
            // 比如 cnt，它是一个标识符，扫描第一个'c'的时候，就已经是终结结点了  
            // 因为单独的'c'也满足标识符的正规表达式的要求  
            // 所以不能停，必须连续走过多个终结结点，把单词完整提取出来  
        
        4. 那么，文本[p:q) 便是提取出的一个完整的单词  
            // 这个单词对应哪种正规表达式呢？  
            // 通过在q前面的那个终结结点的编号，查表（该表在构造ODFA的时候便计算了）  
        
        5. 自动机置为初始状态，从q处开始，返回步骤1继续这么干，直至把文本全部扫描完  


### 二.　伪码 ###

        cnt_line = 1        // 计数器-行号  
        cnt_offset  = 0     // 计数器-行内字符序号  
        cnt_id   = 0        // 计数器-内码  
        
        p = 0               // 单词的起始位置  
        q = 0               // 当前扫描位置  
        N = 待分析文本的总长度  

        while(true)  
        {  
            while(q < N && text[q] == 空白符)  
            {  
                if(text[q] == '\n')     // 碰到换行符，则行号加一，行内字符序号清零  
                {  
                    cnt_line++  
                    cnt_offset = 0  
                }  
                else                    // 碰到空格或tab，则行内字符序号加一  
                    cnt_offset++  
                q++                     // 当前扫描位置后移  
            }  
            
            if(q >= N)                  // 到达文本末尾  
                return  
            
            
            cnt_offset++                // 找到了一个单词的开始位置，行内字符序号加一  
            p = q                       // 找到了一个单词的开始位置，用p记住它  
            
            
            /* 从这个单词的开始位置，直至走到第一个终结结点 */  
            curNode = entrance                          // 自动机的当前状态置为入口结点  
            do  
            {  
                curNode = goto(curNode, text[q])        // 根据终结符text[q]，走到下一个结点上  
                
                if(curNode == -1)                       // 走不通  
                {  
                    出错行号 = cnt_line  
                    行内序号 = cnt_offset  
                    错误单词 = text[p:q]  
                    把 （出错行号,行内序号,错误单词） 写到错误输出流  
                    q++  
                    break                               // 跳过此错误，继续扫描，为了一次性查出所有错误  
                }  
                
                cnt_offset++  
                q++  
            }while(q < N && curNode不是终结结点);  
            
            
            if(curNode != -1 && curNode不是终结结点)      // 到达文本末尾，但是单词没有正常结束  
            {  
                出错行号 = cnt_line  
                行内序号 = cnt_offset - 1  
                错误单词 = text[p:q-1]  
                把 （出错行号,行内序号,错误单词） 写到错误输出流  
            }  
            
            
            /* 从这个终结结点开始，继续走过连续的终结结点，直至走到一个非终结结点 */  
            if(curNode 是终结结点)  
            {  
                mark = curNode              // 用mark来标记真正的终结结点  
            
                while(q < N)  
                {  
                    curNode = goto(curNode, text[q])  
                    if(curNode == -1 || curNode不是终结结点)  
                        break  
                    mark = curNode          // 每当curNode是终结结点，要及时用mark记录它  
                    cnt_offset++  
                    q++  
                }  
                
                单词      = text[p:q-1]  
                内码      = ++cnt_id  
                类型的代号 = T[mark]  
                类型的含义 = RegexConf::Items[类型代号-1].mean  
                把 （单词，内码，类型含义） 写到结果输出流  
            }  
        }  
