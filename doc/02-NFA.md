## 如何根据后缀正则构造NFA ##



### 一. 先来看看NFA涉及哪些操作 ###

        1-1. 根据一个终结符构造出一个简单NFA  
        
            这个NFA只有两个状态（一个开始状态，一个终结状态）  
            这两个状态通过这个终结符边（有向边）相连  
        
        1-2. 对一个NFA施加*操作  
        
            原来的NFA :  
            
            --------------------  
            |                  |  
            |  起始态    终结态  |  
            |                  |  
            --------------------  
            
            变换后的NFA* :  
                           ________  
                          |   ε    |  
                     -----|--------|-----  
                     |    ▽        |    |  
            新始态--->|  起始态    终结态  |--->新终态  
              |   ε  |                  | ε    △  
              |      --------------------      |  
              |________________________________|  
                              ε  

        1-3. 对两个NFA施加.操作  
        
            NFA1-------> NFA2  
                   ε  
        
        1-4. 对两个NFA施加|操作  
        
              -------------> NFA1---------------  
              |     ε                   ε      |  
              |                                ▽  
            新始态                            新终态  
              |                                △  
              |     ε                   ε      |  
              -------------> NFA2---------------  



### 二. 再来考虑NFA的数据结构怎么设计 ###

        观察上面的四种基本操作，发现 :  
        
        不论是*变换，还是对两个NFA进行.合并，还是对两个NFA进行|合并，都只是对原来的NFA的起始结点和终止结点做手脚  
        也就是说，在进行变换和合并的时候，我们只要牢牢抓住起始结点和终止结点，而不必管一个NFA内部是什么样的  
        
        所以，把结点单独封装成一个类，这样一来 :  
        I . NFA这个类里只需要两个结点对象（起始结点&终止结点）就可以了  
        II. 对NFA的遍历可以采取深度优先or广度优先的方式  
        
        下面列出具体的类的设计  



### 三. NFA结点类（NfaNode）的设计 ###

        class NfaNode  
        {  
            private :  
                /* 此结点的编号 */  
                int _id;  
                
                /* 此结点的各发出边上的终结符 */  
                /* 本来终结符是char类型的，这里用int表示，是为了能够用 -1 来表示ε边 */  
                vector<int> _edges;  
                
                /* 此结点的邻接结点们（和上面各发出边的终结符是一一对应的） */  
                vector<NfaNode *> _nexts;  
                
            public :  
                /* 构造函数 */  
                NfaNode(int id);  
                
                /* 析构函数 */  
                ~NfaNode();  
                
                /* 加入一个后继结点，且边的终结符是vt */  
                void addNext(int vt, NfaNode * node);  
        };  



### 四. NFA类的设计 ###

        class NFA  
        {  
            private :  
                /* 起始结点 */  
                NfaNode * _start;  
                
                /* 终止结点 */  
                NfaNode * _end;  
            
            public :  
                /* 根据终结符vt，构造一个简单NFA */  
                /* 参数start_id是这个NFA中的结点的起始编号，因为NFA会不断变换合并，所以需要通过参数来显示指明编号 */  
                NFA(int vt, int start_id);  
                
                /* 析构这个NFA */  
                /* 通过广度优先方式遍历这个图（注意有环，需要验重），把所有结点加入到一个数组中，遍历结束后释放数组中所有结点 */  
                ~NFA();  
                
                /* 根据终结符vt（目前只有*），对一个NFA进行变换 */  
                /* 在变换的时候可能引入新的结点，所以到指明新结点的起始编号 */  
                static void evolve(NFA * nfa, int vt, int start_id);  
                
                /* 根据终结符vt（目前有.和|），对两个NFA进行合并 */  
                /* 在合并的时候可能引入新的结点，所以到指明新结点的起始编号 */  
                /* 注意，把第二个NFA合并到第一个中，原来第二个NFA里的指针置空以节约内存 */  
                static void union(NFA * left, NFA * right, int vt, int start_id);  
        };  
