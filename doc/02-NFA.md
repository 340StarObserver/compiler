## 如何根据后缀正则构造NFA ##



### 一. 先来看看NFA涉及哪些操作 ###

        1-1. 根据一个终结符构造出一个简单NFA  
        
            这个NFA只有两个状态（一个开始状态，一个终结状态）  
            这两个状态通过这个终结符边（有向边）相连  
        
        1-2. 对一个NFA施加*操作  
        
            原来的NFA :  
            
            --------------------  
            |                  |  
            |  起始态    终结态  |  
            |                  |  
            --------------------  
            
            变换后的NFA* :  
                           ________  
                          |   ε    |  
                     -----|--------|-----  
                     |    ▽        |    |  
            新始态--->|  起始态    终结态  |--->新终态  
              |   ε  |                  | ε    △  
              |      --------------------      |  
              |________________________________|  
                              ε  

        1-3. 对两个NFA施加.操作  
        
            NFA1-------> NFA2  
                   ε  
        
        1-4. 对两个NFA施加|操作  
        
              -------------> NFA1---------------  
              |     ε                   ε      |  
              |                                ▽  
            新始态                            新终态  
              |                                △  
              |     ε                   ε      |  
              -------------> NFA2---------------  



### 二. 再来考虑NFA的数据结构怎么设计 ###

        观察上面的四种基本操作，发现 :  
        
        不论是*变换，还是对两个NFA进行.合并，还是对两个NFA进行|合并，都只是对原来的NFA的起始结点和终止结点做手脚  
        也就是说，在进行变换和合并的时候，我们只要牢牢抓住起始结点和终止结点，而不必管一个NFA内部是什么样的  
        
        所以，把结点单独封装成一个类，这样一来 :  
        I . NFA这个类里只需要两个结点对象（起始结点&终止结点）就可以了  
        II. 对NFA的遍历可以采取深度优先or广度优先的方式  
        
        下面列出具体的类的设计  



### 三. NFA结点类（FANode）的设计 ###

        // NFA的结点 与 DFA的结点中的内容并无不同，所以都用FANode就行  

        class FANode  
        {  
            private :  
                /* 此结点的编号 */  
                int _id;  
                
                /* 此结点是否是终结状态（只在DFA中派用场） */  
                bool _terminate;  
                
                /* 此结点的各发出边上的终结符 */  
                /* 本来终结符是char类型的，这里用int表示，是为了能够用 -1 来表示ε边 */  
                vector<int> _edges;  
                
                /* 此结点的邻接结点们（和上面各发出边的终结符是一一对应的） */  
                vector<FANode *> _nexts;  
                
            public :  
                /* 构造函数 */  
                FANode(int id);  
                
                /* 析构函数 */  
                ~FANode();  
                
                /* 加入一个后继结点，且边的终结符是vt */  
                void addNext(int vt, FANode * node);  
        };  



### 四. NFA类的设计 ###

        class NFA  
        {  
            private :  
                /* 起始结点 */  
                FANode * _start;  
                
                /* 终止结点 */  
                FANode * _end;  
            
            public :  
            
                /* 析构这个NFA */  
                /* 通过广度优先方式遍历这个图（注意有环，需要验重），把所有结点加入到一个数组中，遍历结束后释放数组中所有结点 */  
                ~NFA();  
                
                
                
                // 下面的四个函数对应上文说的四种基本操作  
                
                /* 根据终结符vt，构造一个简单NFA */  
                /* 参数start_id是这个NFA中的结点的起始编号，因为NFA会不断变换合并，所以需要通过参数来显示指明编号 */  
                NFA(int vt, int start_id);  
                
                /* 根据终结符'*'，对一个NFA进行闭包变换 */  
                /* 在变换的时候会引入两个新的结点，所以到指明新结点的起始编号 */  
                static void closure(NFA * nfa, int start_id);  
                
                /* 根据终结符'|'，对两个NFA进行合并 */  
                /* 在合并的时候会引入两个新的结点，所以到指明新结点的起始编号 */  
                /* 注意，把第二个NFA合并到第一个中，原来第二个NFA里的指针置空以节约内存 */  
                static void merge(NFA * left, NFA * right, int start_id);  
                
                /* 根据终结符'.'，对两个NFA进行连接 */  
                /* 在连接的时候不会引入新的结点 */  
                /* 注意，把第二个NFA合并到第一个中，原来第二个NFA里的指针置空以节约内存 */  
                static void join(NFA * left, NFA * right);  
                
                
                
                // 下面的三个函数是利用上面的四个函数，来做的一些封装，好让用户用的更方便  
                
                /* 构造一个NFA，by 单独的一个后缀正则表达式 */  
                /* 注意，参数start_id是引用传递，方便构造下一个NFA的时候知道结点编号应该从什么值开始 */  
                static NFA * create(const string & suffixRegex, int & start_id);  
                
                /* 构造一个大NFA，by 多个后缀正则表达式 */  
                static NFA * create(const vector<string> & suffixs);  
                
                /* 构造一个大NFA，by 默认的一些正则表达式 */  
                static NFA * create();  
        };  



### 五. 由后缀正则构造NFA的算法 ###

        在上文中，我们分析并设计了NFA的四种基本操作 :  
        {  
            1. 根据一个终结符，构造出一个简单NFA  ---- 对应 NFA的构造函数  
            2. 对一个已有的NFA进行闭包操作       ---- 对应 NFA::closure 函数  
            3. 对两个NFA进行'|'式的合并         ---- 对应 NFA::merge 函数  
            4. 对两个NFA进行连接操作            ---- 对应 NFA::join 函数  
        }  
        
        那么，根据这四种基本操作，我们就可以根据一个后缀正则，来构造出复杂的NFA了  
        // 至于如何构造后缀正则，请参考"doc/01-SuffixRegex.md"  
        
        算法逻辑 :  
        
            创建一个空栈  
            
            从左向右扫描后缀正则表达式  
            {  
                记当前输入符号为 ch  
                
                if( ch == '*' )  
                {  
                    对栈顶的NFA进行闭包操作  
                }  
                
                else if( ch == '|' )  
                {  
                    依次从栈中弹出 NFA1, NFA2  
                    把 NFA2|NFA1 压栈  
                    删除NFA1  
                }  
                
                else if( ch == '.' )  
                {  
                    依次从栈中弹出 NFA1, NFA2  
                    把　NFA2.NFA1 压栈  
                    删除NFA1  
                }  
                
                else  
                {  
                    // 即ch为终结符  
                    根据ch创建一个简单NFA，并压栈  
                }  
            }  
            
            此时，栈顶的元素就是最终的NFA  



### 六.　根据多个后缀正则构造NFA的算法 ###

        我们知道，单单把一个后缀正则转化为NFA是不够的  
        我们需要把所有正则的NFA合并成一个大的NFA，然后才能执行确定化的操作使之变换为DFA  
        
        而在上文中，我们已经分析出了如何根据一个后缀正则来构造NFA  
        那么，多个正则，就只要把每个正则对应的NFA用'|'合并起来就好啦  
